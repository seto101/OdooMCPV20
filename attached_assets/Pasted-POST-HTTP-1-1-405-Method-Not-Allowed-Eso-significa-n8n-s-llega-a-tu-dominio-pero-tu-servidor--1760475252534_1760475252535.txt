POST / HTTP/1.1" 405 Method Not Allowed

Eso significa: n8n sí llega a tu dominio, pero tu servidor no acepta POST en la ruta que n8n está usando. No es auth (sería 401/403) ni red (no verías 405). Es mismatch de transporte/ruta.

Qué está pasando (resumen)

n8n (MCP Client) con “HTTP Streamable” intenta POST / para abrir el stream MCP.

Tu servidor responde 200 a GET / y GET /health (bien), pero no implementa POST / → 405.

Conclusión: o la ruta es distinta (p.ej. /mcp, /stream, /messages), o tu server no está corriendo el transport “HTTP Streamable” (podría ser solo stdio, ws, o SSE).

Checklist rápido (hazlo tal cual)

Confirma qué transporte expone tu server MCP.

Si lo levantaste con algo tipo mcp-serve-http ..., debería aceptar POST /.

Si lo levantaste como WebSocket (ws/wss), cambia en n8n Server Transport → WebSocket.

Si es SSE, elige “HTTP SSE” (si tu nodo lo muestra) y usa la ruta correcta.

Comprueba rutas disponibles del server.
(desde cualquier terminal)

curl -i https://TU_SUBDOMINIO.ngrok-free.dev/
curl -i https://TU_SUBDOMINIO.ngrok-free.dev/health
curl -i -X POST https://TU_SUBDOMINIO.ngrok-free.dev/
curl -i https://TU_SUBDOMINIO.ngrok-free.dev/openapi.json   # si es FastAPI
curl -i https://TU_SUBDOMINIO.ngrok-free.dev/docs           # puede listar rutas


Si POST / sigue en 405, averigua la ruta MCP que sí acepta POST (p.ej. /mcp):

curl -i -X POST https://TU_SUBDOMINIO.ngrok-free.dev/mcp


Ajusta el “Endpoint” en n8n a la ruta exacta que acepta el handshake (ej.: https://…/mcp), no solo al dominio raíz.

Bearer token

En n8n: Authentication = Bearer Auth y pon el mismo token que tu server espera.

Verifica que tu server realmente verifica Authorization: Bearer .... Si no lo hace, igual debería dar 401/403, no 405. Así que la prioridad sigue siendo la ruta/transporte.

Si tu server es solo stdio (muchos MCP servers lo son por defecto):
Envuelve con bridge HTTP streamable:

# Ejemplo genérico
mcp-serve-http \
  --port 8000 \
  --bearer-token "$TOKEN" \
  -- ./tu-servidor-mcp-stdio --sus --flags
# Ahora sí: n8n → HTTP Streamable → https://...:8000/


(La idea: tu binario MCP habla stdio y el wrapper expone el endpoint HTTP que n8n necesita.)

WebSocket (si aplica)
Si tu implementación expone ws:///wss://:

Cambia en n8n a Server Transport: WebSocket.

Endpoint: wss://TU_SUBDOMINIO.ngrok-free.dev/<ruta_ws>

En ngrok, funciona bien con wss.

Diagnóstico por lo que muestras

Logs: GET / y GET /health → 200 OK (verde ✅).

POST / desde IP externa → 405 (rojo) → ruta/transport incorrecto.

Por eso n8n muestra “Could not connect to your MCP server”.

Qué probar ahora (en orden)

Intenta cambiar el Endpoint en n8n a https://…/mcp (o la ruta que tu server exponga) y vuelve a ejecutar.

Si sigue 405, cambia Server Transport:

a WebSocket si tu server es ws/wss;

o a HTTP SSE si es SSE.

Si tu server solo corre stdio, levanta el bridge HTTP streamable como arriba y apunta n8n ahí.